using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Sean.Utility.Common;
using Sean.Utility.Contracts;
using Sean.Utility.Enums;
using Sean.Utility.Extensions;
using Sean.Utility.IO;
#if NETSTANDARD
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
#endif

namespace Sean.Utility.Impls.Log
{
    public abstract class SimpleLocalLoggerBase : ISimpleLoggerBase
    {
        /// <summary>
        /// Custom processing message format, default: [yyyy-MM-ddTHH:mm:sszzz] [logLevel] [classType.FullName] => msg
        /// </summary>
        /// <remarks>
        /// 自定义处理消息格式，默认为：[yyyy-MM-ddTHH:mm:sszzz] [logLevel] [classType.FullName] => msg
        /// </remarks>
        public static event EventHandler<MsgFormatEventArgs> MsgFormat;
        /// <summary>
        /// Custom output log.
        /// </summary>
        /// <remarks>
        /// 自定义输出日志。
        /// </remarks>
        public static event EventHandler<CustomOutputLogEventArgs> CustomOutputLog;
        /// <summary>
        /// To handle internal exceptions, the default output log is: Console, \Log\internal.log.
        /// </summary>
        /// <remarks>
        /// 处理内部异常，默认输出日志到：Console、\Log\internal.log。
        /// </remarks>
        public static event EventHandler<EventArgs<Exception>> OnException;

        /// <summary>
        /// 时间格式化
        /// </summary>
        public static Func<DateTime, string> DateTimeFormat { get; set; }
        /// <summary>
        /// Log file path, automatically generated by time by default: \Log\yyyy-MM-dd.log.
        /// </summary>
        /// <remarks>
        /// 日志文件路径，默认情况下会自动按时间生成：\Log\yyyy-MM-dd.log。
        /// </remarks>
        public static Func<string> LogFilePath { get; set; } = () => Path.Combine(GetLogBaseDir(), $"{DateTime.Now:yyyy-MM-dd}.log");
        /// <summary>
        /// Encoding, The default value is UTF8.
        /// </summary>
        /// <remarks>
        /// Encoding，默认值为UTF8。
        /// </remarks>
        public static Encoding DefaultEncoding { get; set; } = Encoding.UTF8;

        public ISimpleLocalLoggerOptions Options => _options;

        protected Type ClassType;

        private readonly SimpleLocalLoggerOptions _options;

#if NETSTANDARD
        internal static IServiceProvider ServiceProvider { get; set; }
#endif

        private static readonly ReaderWriterLockSlim _locker = new ReaderWriterLockSlim();

        protected SimpleLocalLoggerBase() : this(null)
        {

        }

        protected SimpleLocalLoggerBase(Action<SimpleLocalLoggerOptions> options)
        {
#if NETSTANDARD
            _options = ServiceProvider?.GetService<IOptionsMonitor<SimpleLocalLoggerOptions>>().CurrentValue ?? new SimpleLocalLoggerOptions();
#else
            _options = new SimpleLocalLoggerOptions();
#endif

            options?.Invoke(_options);
        }

        public virtual void Log(LogLevel logLevel, string msg, Exception ex = null)
        {
            try
            {
                // 输出日志 => 自定义（默认无）
                CustomOutputLog?.Invoke(this, new CustomOutputLogEventArgs(_options, logLevel, msg, ex));

                if (!_options.LogToConsole && !_options.LogToLocalFile)
                {
                    return;
                }

                string msgFormat;
                bool hasOutputConsole;
                if (MsgFormat != null)
                {
                    var args = new MsgFormatEventArgs(_options, ClassType, logLevel, msg, ex);
                    MsgFormat(this, args);
                    msgFormat = args.MsgFormat;
                    hasOutputConsole = args.HasOutputConsole;
                }
                else
                {
                    msgFormat = DefaultHandleMsgFormat(ClassType, logLevel, msg, ex, out hasOutputConsole);
                }

                if (!string.IsNullOrWhiteSpace(msgFormat))
                {
                    if (!hasOutputConsole && _options.LogToConsole && logLevel >= _options.MinLogLevelForConsole)
                    {
                        // 输出日志 => 控制台
                        Console.WriteLine(msgFormat);
                    }

                    if (_options.LogToLocalFile && logLevel >= _options.MinLogLevelForLocalFile)
                    {
                        // 输出日志 => 本地文件
                        try
                        {
                            _locker.EnterWriteLock();

                            var filePath = LogFilePath?.Invoke();
                            if (string.IsNullOrWhiteSpace(filePath))
                            {
                                throw new Exception("Log file path cannot be empty!");
                            }

                            #region 日志文件备份
                            if (_options.MaxFileSize > 0 && File.Exists(filePath))
                            {
                                //var msgByteCount = Options.DefaultEncoding.GetByteCount(msgFormat);
                                var fileInfo = new FileInfo(filePath);
                                if (fileInfo.Length >= _options.MaxFileSize)
                                {
                                    var backupFilePath = PathHelper.GetBackupFilePath(filePath, out _);
                                    File.Move(filePath, backupFilePath);
                                }
                            }
                            #endregion

                            //using (var sw = File.AppendText(filePath))
                            using (var sw = new StreamWriter(filePath, true, DefaultEncoding))
                            {
                                sw.WriteLine(msgFormat);
                                sw.Close();
                            }
                        }
                        finally
                        {
                            if (_locker.IsWriteLockHeld)
                            {
                                _locker.ExitWriteLock();
                            }
                        }
                    }
                }
            }
            catch (Exception exception)
            {
                if (OnException != null)
                {
                    OnException(this, new EventArgs<Exception>(exception));
                }
                else
                {
                    DefaultHandleInternalException(exception);
                }
            }
        }

        public virtual Task LogAsync(LogLevel logLevel, string msg, Exception ex = null)
        {
            return Task.Factory.StartNewCatchException(() =>
            {
                Log(logLevel, msg, ex);
            });
        }

        private string DefaultHandleMsgFormat(Type classType, LogLevel logLevel, string msg, Exception exception, out bool outputConsole)
        {
            outputConsole = _options.LogToConsole && logLevel >= _options.MinLogLevelForConsole;

            //var result = $"[{(DateTimeFormat != null ? DateTimeFormat(DateTime.Now) : DateTime.Now.ToLongDateTimeWithTimezone())}] [{logLevel}]{(classType != null ? $" [{classType.FullName}]" : string.Empty)} => {msg}{(exception != null ? $"{Environment.NewLine}Message: {exception.Message}{Environment.NewLine}StackTrace: {exception.StackTrace}" : string.Empty)}";

            var sb = new StringBuilder();
            MsgFormatToConsole($"[{(DateTimeFormat != null ? DateTimeFormat(DateTime.Now) : DateTime.Now.ToLongDateTimeWithTimezone())}] [", sb, outputConsole);
            MsgFormatToConsole(logLevel.ToString(), sb, outputConsole, logLevel.GetConsoleColor());
            MsgFormatToConsole("]", sb, outputConsole);
            if (classType != null)
            {
                MsgFormatToConsole(" [", sb, outputConsole);
                MsgFormatToConsole(classType.FullName, sb, outputConsole, ConsoleColor.Green);
                MsgFormatToConsole("]", sb, outputConsole);
            }
            MsgFormatToConsole($" => {msg}", sb, outputConsole);
            if (exception != null)
            {
                MsgFormatToConsole(Environment.NewLine, sb, outputConsole);
                MsgFormatToConsole($"Message: {exception.Message}", sb, outputConsole, ConsoleColor.Red);
                if (!string.IsNullOrWhiteSpace(exception.StackTrace))
                {
                    MsgFormatToConsole(Environment.NewLine, sb, outputConsole);
                    MsgFormatToConsole($"StackTrace: {exception.StackTrace}", sb, outputConsole, ConsoleColor.Red);
                }
            }

            if (outputConsole) ConsoleHelper.WriteLine();

            //Console.WriteLine(sb.ToString());
            return sb.ToString();// result
        }

        private void MsgFormatToConsole(string msg, StringBuilder sb, bool outputConsole, ConsoleColor? color = null)
        {
            sb.Append(msg);
            if (outputConsole) ConsoleHelper.Write(msg, color);
        }

        private void DefaultHandleInternalException(Exception exception)
        {
            if (exception == null) return;

            try
            {
                var msg = DefaultHandleMsgFormat(this.GetType(), LogLevel.Fatal, "Internal error.", exception, out _);
                using (var sw = File.AppendText(Path.Combine(GetLogBaseDir(), "internal.log")))
                {
                    sw.WriteLine(msg);
                    sw.Close();
                }
            }
            catch
            {
                // ignored
            }
        }

        private static string GetLogBaseDir()
        {
            var dir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Log");
            if (!Directory.Exists(dir))
            {
                Directory.CreateDirectory(dir);
            }
            return dir;
        }
    }
}
